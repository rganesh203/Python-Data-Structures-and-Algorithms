# Python-Data-Structures-and-Algorithms
![image](https://github.com/user-attachments/assets/ddec9ba6-75c1-4b6b-919a-e458558347b9)

Data Structures is about how data can be stored in different structures. Algorithms is about how to solve different problems, often by searching through and manipulating data structures. Theory about Data Structures and Algorithms (DSA) helps us to use large amounts of data to solve problems efficiently.

1. DATA STRUCTURE PRELIMINARIES 
    1.1 Concept of Data Type 
    1.1.1 Primitive data type 
    1.1.2 User defined data type 
    1.1.3 Abstract data type 
    1.2 What Is Data Structure? 
    1.3 Definition and Brief Description of Various Data Structures 
    1.3.1 Array 
    1.3.2 Linked list 
    1.3.3 Stack 
    1.3.4 Queue 
    1.3.5 Graph 
    1.3.6 Tree 
    1.3.7 Heap 
    1.4 Data Structures versus Data Types 
    1.5 Operations on Data Structures

2. INTRODUCTION TO ALGORITHM 
    2.1 What Is an Algorithm? 
    2.2 Importance of an Algorithm 
    2.3 Different Approaches to Designing an Algorithm 
    2.4 Algorithm Design Tools: Flowchart and Pseudocode 
    2.4.1 Flowchart 
    2.4.2 Pseudocode 
    2.5 Control Structures Used in an Algorithm 
    2.6 Time and space complexity 
    2.7 Best Case, Worst Case, Average Case Time Complexity 
    2.8 Time–Space Trade-off 
    2.9 Frequency Count and Its Importance 
    2.10 Analyzing Algorithms 
    2.10.1 Big O Notation 
    2.10.2 Ω (Omega) Notation 
    2.10.3 Θ (Theta) Notation 
    2.10.4 Other Useful Notations 
    2.11 Divide and Conquer Strategy 
    2.12 Dynamic Programming 
    2.13 Greedy Method

3. ARRAY
    3.1 Definition 
    3.2 Creating an Array 
    3.3 Accessing Elements of an Array 
    3.4 Operations on an Array 
    3.4.1 Adding Elements to an Array 
    3.4.2 Removing Elements from an Array 
    3.4.3 Slicing of an Array 
    3.4.4 Searching Element in an Array 
    3.4.5 Updating Elements in an Array 
    3.4.6 Concatenation of Arrays 
    3.4.7 Multiplication or Repetition on Array 
    3.5 Representation of Polynomials 
    3.6 Two Dimensional Array 
    3.7 Creation of a Two Dimensional Array 
    3.8 Accessing Elements of a Two Dimensional Array 
    3.9 Representation of a Two Dimensional Array in Memory 
    3.9.1 Row Major Representation 
    3.9.2 Column Major Representation 
    3.10 Operations on Two Dimensional Arrays 
    3.10.1 Matrix Addition 
    3.10.2 Matrix Multiplication 
    3.10.3 Transpose of a Matrix 
    3.10.4 Slicing of a Matrix 
    3.11 Sparse Matrix 
    3.12 Programming Examples 

4. PYTHON DATA STRUCTURES 
    4.1 Lists 
    4.1.1 Creating a List 
    4.1.2 Accessing List Elements 
    4.1.3 Operations on a List 
    4.1.3.1 Adding Elements to a List 
    4.1.3.2 Removing Elements from a List 
    4.1.3.3 Slicing of a List 
    4.1.3.4 Searching Element in a List 
    4.1.3.5 Updating Elements in a List 
    4.1.3.6 Concatenation of Lists 
    4.1.3.7 Multiplication or Repetition of List 
    4.1.4 Nested List 
    4.1.5 List Functions 
    4.1.6 List Methods 
    4.1.7 Looping in a List 
    4.1.8 List vs. Array 
    4.2 Tuples 
    4.2.1 Creating a Tuple 
    4.2.2 Accessing Tuple Elements 
    4.2.3 Operations on Tuple 
    4.2.4 Nested Tuples 
    4.2.5 Tuple Methods 
    4.2.6 Looping in a Tuple 
    4.3 Sets 
    4.3.1 Creating a Set 
    4.3.2 Operations on a Set 
    4.3.2.1 Adding Elements to a Set 
    4.3.2.2 Removing Elements from a Set 
    4.3.2.3 Searching an Element in a Set 
    4.3.3 Set Methods 
    4.3.4 Frozenset 
    4.4 Dictionaries 
    4.4.1 Creating a Dictionary 
    4.4.2 Accessing Values in a Dictionary 
    4.4.3 Operations on a Dictionary 
    4.4.3.1 Adding and Modifying an Element in a Dictionary 
    4.4.3.2 Removing an Element from a Dictionary 
    4.4.3.3 Membership Test in a Dictionary 
    4.4.4 Looping in a Dictionary 
    4.4.5 Nested Dictionaries 
    4.4.6 Dictionary Methods 
    4.5 Comparative Study 
    4.6 Programming Examples 
Python Data Structures at a Glance 
5. STRINGS 145
    5.1 Introduction 
    5.2 Basic String Operations 
    5.2.1 Slicing Operations on String 
    5.2.2 Concatenation and Repeating Operation on Strings 
    5.3 Looping through a String 
    5.4 String Methods 
    5.5 String Comparison 
    5.6 Regular Expressions 
    5.7 Pattern Matching Algorithms 
    5.7.1 Brute Force Pattern Matching Algorithm 
    5.7.2 Knuth Morris Pratt Pattern Matching Algorithm 
    5.8 Programming Example 

6. RECURSION 
    6.1 Definition 
    6.2 Types of Recursion 
    6.3 Recursion vs. Iteration 
    6.4 Some Classical Problems on Recursion 
    6.4.1 Towers of Hanoi Problem 
    6.4.2 Eight Queen Problem 
    6.5 Advantages and Disadvantages of Recursion 
    6.6 Analysis of Recursive Algorithms 
    6.7 Programming Examples 

7. LINKED LIST
    7.1 Definition 
    7.2 Advantages of a Linked List 
    7.3 Types of Linked Lists 
    7.4 Implementing a Singly Linked List 
    7.5 Operations on Singly Linked List 
    7.5.1 Creating a Singly Linked List 
    7.5.2 Displaying a Singly Linked List 
    7.5.3 Inserting a New Element in a Singly Linked List 
    7.5.3.1 Inserting an Element at the Beginning of a List 
    7.5.3.2 Inserting an Element at the End of a List 
    7.5.3.3 Inserting a Node after a Specified Node 
    7.5.3.4 Inserting a Node before a Specified Node 
    7.5.4 Deleting a Node from a Singly Linked List 
    7.5.4.1 Deleting the First Node 
    7.5.4.2 Deleting the Last Node 
    7.5.4.3 Deleting any Intermediate Node 
    7.6 Applications of a Singly Linked List 
    7.7 Implementing a Circular Singly Linked List 
    7.8 Operations on a Circular Singly Linked List 
    7.8.1 Creating a Circular Singly Linked List 
    7.8.2 Displaying a Circular Singly Linked List 
    7.8.3 Inserting a New Element in a Circular Linked List 
    7.8.3.1 Inserting an Element at the Beginning of a Circular Linked List 
    7.8.3.2 Inserting an Element at the End of a List 
    7.8.3.3 Inserting a Node after a Specified Node 
    7.8.3.4 Inserting a Node before a Specified Node 
    7.8.4 Deleting a Node from a Circular Singly Linked List 
    7.8.4.1 Deleting the First Node 
    7.8.4.2 Deleting the Last Node 
    7.8.4.3 Deleting any Intermediate Node 
    7.9 Applications of a Circular Singly Linked List 
    7.10 Implementing a Doubly Linked List 
    7.11 Operations on a Doubly Linked List 
    7.11.1 Inserting an Element at the Beginning of a Doubly Linked List 
    7.11.2 Inserting an Element at the End of a Doubly Linked List 
    7.11.3 Inserting a Node at a Specified Position in a Doubly Linked List 
    7.11.4 Deleting a Node from a Doubly Linked List 
    7.11.4.1 Deleting the First Node 
    7.11.4.2 Deleting the Last Node 
    7.11.4.3 Deleting any Intermediate Node 
    7.12 Implementation of a Circular Doubly Linked List 
    7.13 Operations on a Circular Doubly Linked List 
    7.13.1 Inserting an Element at the Beginning of a Circular Doubly Linked List 
    7.13.2 Inserting an Element at the End of a Circular Doubly Linked List 
    7.13.3 Deleting the First Node from a Circular Doubly Linked List 
    7.13.4 Deleting the Last Node from a Circular Doubly Linked List 
    7.14 Header Linked List 
    7.15 Advantages of a Header Linked List 
    7.16 Disadvantages of a Linked List 
    7.17 Programming Examples 

8. STACK 
    8.1 Definitions and Concept 
    8.2 Operations Associated with Stacks 
    8.3 Representation of a Stack 
    8.3.1 Array Representation 
    8.3.2 Python List Representation 
    8.3.3 Linked Representation 
    8.4 Multiple Stacks 
    8.5 Applications of a Stack 
    8.5.1 Parenthesis Checking Problem 
    8.5.2 Conversion and Evaluation of Different Arithmetic Expressions 
    8.5.2.1 Different Notations of Arithmetic Expressions 
    8.5.2.2 Conversion of an Infix Expression into a Postfix Expression 
    8.5.2.3 Evaluation of a Postfix Expression 
    8.5.2.4 Conversion of a Postfix Expression into an Infix Expression 
    8.5.2.5 Conversion of an Infix Expression into a Prefix Expression 
    8.5.3 Reversing any Sequence 
    8.5.4 Recursion 
   
10. QUEUE 
    9.1 Definitions and Concept 
    9.2 Operations Associated with Queues 
    9.3 Representation of a Queue 
    9.3.1 Array Representation of a Queue 
    9.3.2 Circular Queue 
    9.3.2.1 Operations on a Circular Queue 
    9.3.3 Python List Representation of a Queue 
    9.3.4 Linked Representation of a Queue 
    9.3.4.1 Using a Header List 
    9.3.4.2 Using a Single Circular Linked List with a Single Tail Pointer 
    9.4 Multiple Queues 
    9.5 Special Queues 
    9.5.1 DEQue 
    9.5.2 Priority Queue 
    9.6 Applications of a Queue 
   
11. TREES 
    10.1 Definition and Concept 
    10.2 Terminology 
    10.3 Types of Trees 
    10.3.1 General Tree 
    10.3.2 Forest 
    10.3.3 Binary Tree 
    10.3.4 Strictly Binary Tree 
    10.3.5 Complete Binary Tree 
    10.3.6 Full Binary Tree 
    10.3.7 Extended Binary Tree 
    10.3.8 Binary Search Tree (BST) 
    10.3.9 Expression Tree 
    10.3.10 Tournament Tree 
    10.4 Representation of a Binary Tree 
    10.4.1 Array Representation of a Binary Tree 
    10.4.2 Linked list Representation of a Binary Tree 
    10.5 Binary Tree Traversal 
    10.5.1 Preorder Traversal of a Binary Tree 
    10.5.2 Inorder Traversal of a Binary Tree 
    10.5.3 Postorder Traversal of a Binary Tree 
    10.5.4 Level Order Traversal of a Binary Tree 
    10.6 Construction of a Binary Tree from the Traversal Path 
    10.7 Conversion of a General Tree to a Binary Tree 
    10.8 Binary Search Tree (BST) 
    10.9 Operations on a Binary Search Tree – Recursive and Non-recursive 
    10.9.1 Insertion of a New Node in a Binary Search Tree 
    10.9.2 Searching a Node in a Binary Search Tree 
    10.9.3 Traversing a Binary Search Tree 
    10.9.4 Deletion of a Node from a Binary Search Tree 
    10.9.5 Find the Largest Node from a Binary Search Tree 
    10.9.6 Finding the Smallest Node from a Binary Search Tree 
    10.9.7 Counting the Total Number of Nodes in a Binary Search Tree 
    10.9.8 Counting the Number of External Nodes in a Binary Search Tree 
    10.9.9 Counting the Number of Internal Nodes in a Binary Search Tree 
    10.9.10 Finding the Height of a Binary Search Tree 
    10.9.11 Finding the Mirror Image of a Binary Search Tree 
    10.10 Threaded Binary Tree 
    10.10.1 Representation of a Threaded Binary Tree 
    10.10.2 Operations on an Inorder Threaded Binary Tree 
    10.10.2.1 Inorder Traversal of an Inorder Threaded Binary Tree 
    10.10.2.2 Inserting a New Node in an Inorder Threaded Binary Search Tree 
    10.10.2.3 Deletion of a Node from an Inorder Threaded Binary Search Tree 
    10.11 AVL Tree 
    10.11.1 Operations on an AVL Tree 
    10.11.1.1 Insertiing a Node in an AVL Tree 
    10.11.1.2 Deleting a Node from an AVL Tree 
    10.12 Red–Black Tree 
    10.12.1 Inserting a New Node in a Red–Black Tree 
    10.12.2 Deleting a Node from a Red–Black Tree 
    10.13 Huffman Coding 
    10.14 M-way Search Trees 
    10.15 B Tree 
    10.15.1 Inserting a New Element in a B Tree 
    10.15.2 Deleting Elements from a B Tree 
    10.15.3 Searching an Element from a B Tree 
    10.16 B+ Tree 
    10.16.1 Inserting a New Element in a B+ Tree 
    10.16.2 Deleting Elements from a B+ Tree 
    10.17 B* Tree 
    10.18 2–3 Tree 
    10.19 Trie Tree 

12.  HEAP 
    11.1 Definition and Concept 
    11.2 Representation of a Heap in Memory 
    11.3 Operations on a Heap 
    11.3.1 Inserting a New Element in a Heap 
    11.3.2 Deleting an Element from a Heap 
    11.4 Applications of Heap 
    11.4.1 Implementing a Priority Queue Using Heap 

12.GRAPH 
    12.1 Definition and Concept 
    12.2 Terminology 
    12.3 Representation of a Graph 
    12.3.1 Adjacency Matrix Representation 
    12.3.2 Incidence Matrix Representation 
    12.3.3 Adjacency List Representation 
    12.3.4 Adjacency Multi-list Representation 
    12.4 Operations on a Graph 
    12.4.1 Insertion Operation 
    12.4.2 Deletion Operation 
    12.4.3 Graph Traversal 
    12.4.3.1 Breadth First Search Algorithm 
    12.4.3.2 Depth First Search Algorithm 
    12.5 Minimum Spanning Tree 
    12.5.1 Prim’s Algorithm 
    12.5.2 Kruskal’s Algorithm 
    12.6 Shortest Path Algorithm 
    12.6.1 Within a Given Source and Destination 
    12.6.2 Among All Pairs of Vertices 
    12.7 Applications of Graph 

13.  SEARCHING AND SORTING 
    13.1 Introduction to Searching 
    13.1.1 Linear Search 
    13.1.2 Binary Search 
    13.1.3 Interpolation Search 
    13.2 Introduction to Sorting 
    13.2.1 Bubble Sort 
    13.2.2 Selection Sort 
    13.2.3 Insertion Sort 
    13.2.4 Quick Sort 
    13.2.5 Merge Sort 
    13.2.6 Heap Sort 
    13.2.7 Radix Sort 
    13.2.8 Shell Sort 
    13.3 Comparison of Different Sorting Algorithms 
    13.4 Concept of Internal and External Sorting 
     
15.  HASHING 
    14.1 Definitions and Concept 
    14.2 Hash Functions 
    14.2.1 Division Method 
    14.2.2 Multiplication Method 
    14.2.3 Mid-square Method 
    14.2.4 Folding Method 
    14.2.5 Length Dependent Method 
    14.2.6 Digit Analysis Method 
    14.3 Collision Resolution Technique 
    14.3.1 Open Addressing 
    14.3.1.1 Linear Probing 
    14.3.1.2 Quadratic Probing 
    14.3.1.3 Double Hashing 
    14.3.2 Chaining 
    14.4 Rehashing 
    14.5 Applications of Hashing 
